\documentclass[conference, a4paper]{IEEEtran}

% used for flow charts
\usepackage{pgf}
\usepackage{tikz}
\usepackage{reotex}

\usepackage{amssymb}
\usepackage{cite}
\usepackage[normalem]{ulem}
% for a smile-face character
\usepackage{wasysym}
% FIXME finally no todos should exist in this draft
\usepackage[textsize=tiny]{todonotes}
% positioning is used for below lef = of
\usetikzlibrary{shapes,arrows,automata,positioning}
% some tikz-styles on reo channels, not required in papers that have nothing to do with Reo

% declaration of environments
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

% personal characters
\newcommand{\rblock}[0]{\circleddash}
\newcommand{\rread}[0]{\smiley}
\newcommand{\rnoread}[0]{\frownie}


\title{Active Learning : From Blackbox To Timed Connectors}
\author{
\IEEEauthorblockN{Yi Li\IEEEauthorrefmark{1} and Meng Sun\IEEEauthorrefmark{1}}
\IEEEauthorblockA{
  \IEEEauthorrefmark{1}DI, School of Mathematical Sciences, Peking University,
  Beijing, China\\
  liyi\_math@pku.edu.cn, summeng@math.pku.edu.cn
}
}

\begin{document}
\maketitle
\begin{abstract}
  Coordination is becoming more and more important, especially in concurrent programming and
  distributed systems. More and more tools are built to verify coordination models while most of
  them are facing the same problem: \emph{lack of models}. In many cases, somehow we need to check a
  connector with nothing more than a binary file. In this paper, we present a learning-based
  framework to formally verify a Reo connector in case there is no source code. From some practical
  cases, we've shown the effciency of our approach. Both the algorithm and Reo itself have been
  ported to \emph{Golang}, making it fully-prepared for parallel programming.
\end{abstract}

\begin{IEEEkeywords}
  active learning, coordination, formal method.
\end{IEEEkeywords}

\section{Introduction}

In the past few years, researchers have been focusing on this area, and come up with a
series of impressive works. 
\todo{a list}
However, most of these works are based on models, instead of binaries. Then it comes a well-known
problem: \emph{how can we obtain these models?}

To solve this problem, many techniques in model constructing were proposed, for instance in
\cite{DBLP:journals/mt/Daelemans10, DBLP:journals/iandc/Angluin87, DBLP:conf/fase/RaffeltS06}.

% it seems that we need a graph to describe how we're doing this work
\todo{better graph}
\input{images/flow.tex}

In this paper, we presented an adapted active learning algorithm to extract timed Reo connectors
from binaries with no source code needed.

\section{Preliminaries}

\subsection{Reo Coordination Language}
\label{sec:reo}
Reo Coordination Language\cite{DBLP:journals/mscs/Arbab04}

\begin{figure}[h]
  \begin{center}
    \input{./images/basic.tex}
  \end{center}
  \caption{Basic Reo Channels}
  \label{fig:basic}
\end{figure}

\subsection{Active Learning and Mealy Machines}

\section{Timed Connectors as Mealy Machines}

\subsection{External Behavior of Reo Connectors}
So far as we can tell, most
works\cite{DBLP:conf/fase/RaffeltS06, DBLP:journals/corr/ChenHLLTWW15} on automata learning are not
capable of infinite models. \todo{reason?} Considering the semantics defined in section
\ref{sec:reo}, it's apparent that every finite connector has a corresponding constraint
automata, and the automata is also finite. Unfortunately, when checking the further definition of
Reo connectors' input, we find that it's not the case.

\todo{an example as graph}

\begin{figure}[h]
  \caption{Infinite States in a Reo Model}
  \label{fig:reoinfinite}
\end{figure}

While focusing on behavior of connectors, Reo doesn't give detail depiction on behavior of
components. As shown in \figurename \ref{fig:reoinfinite}, connectors are able to reject any datum
if they are not ready. But what will happen outside the connector, if the datum is rejected? This
question deserves careful consideration if we are taking an external view.

\subsection{Time Domain}
Time is involved in several extension of Reo like timed Reo, hybrid Reo, etc.
Generally, these models are designed to handle real-time behavior where time is defined in
$\mathbb{R}$. However, we also found a lot of works where authors use rational time to make things
easier\todo{citations}.

In this paper, we choose the rational number field $\mathbb{Q}$ as our time domain, which simplifies
discretization of timed behaviors greatly.

As presented in section \ref{sec:reo}, all real-time behavior in timed Reo comes with the
\emph{t-timer} channels, and the number of these channels are apparently finite. We use
$t_i\in\mathbb{Q}$ to denote the delays of these timer channels, and now we can define a precision
function $prec$.
\[
prec(t_1,\cdots,t_n) = \max_T\{\forall t_i.\exists n_i\in\mathbb{N}.t_i=n_i\cdot T\}
\]
It's easy to prove that such a $T$ is always existing.

In real systems, the concept \emph{time precision} is widely used with the name ``clock-period''.
Most of the time, we know the clock-cycle of some hardware components, even without any idea of its
structure. With such precision $T$ given, it's reasonable to assume that all $t$-timers are actually
$nT$-timers. In following sections, we'll use $n$-timers instead.

Besides, we're going to add a ``T'' action in mealy machines. It indicates that a transition
will take a time unit to finish, and all outputs would come out after that.

\subsection{Parameterized Mealy Machine}
We present a model named \emph{parameterized mealy machine} to represent timed connectors
(hereinafter referred to as PMM). 

This model is supposed to behave as a middle representation. Connectors are defined as parameterized
mealy machines, and composed via its production operator. Then original mealy-machine model will be
taken as semantics of PMM model.

\begin{definition}[Parameterized Mealy Machine]
  A \emph{Parameterized Mealy Machine} is defined as a function $\mathcal{PM}(\Sigma)=\langle
  S(\Sigma), s_0, I, O, \delta(\Sigma), \lambda(\Sigma)\rangle$ that maps an
  alphabet to its corresponding Mealy Machine. 
  \begin{itemize}
    \item[-] $\Sigma$ is a \emph{finite} datum alphabet (hereinafter referred to as an alphabet)
    \item[-] $S$ is a function that maps an alphabet to a \emph{finite} set of
      states. We use $S(\Sigma)$ to denote the state set.
    \item[-] $I$ is a finite set of source-ends.
    \item[-] $O$ is a finite set of sink-ends.
    \item[-] $s_0$ is the initial state. It satisfies $\forall \Sigma,s_0\in S(\Sigma)$
    \item[-] $\delta$ maps a \emph{finite} datum alphabet to an \emph{output function}. We use
      $\delta(\Sigma):S(\Sigma)\times Input(\Sigma,I)\rightarrow Output(\Sigma, O)$ to denote the output function.
    \item[-] $\lambda$ maps an alphabet to a \emph{transition function}. We use
      $\lambda(\Sigma):S(\Sigma)\times Input(\Sigma,I)\rightarrow S(\Sigma)$ to denote the transiton
      function.
  \end{itemize}
\end{definition}

In the definition above, \emph{Input} and \emph{Output} are used to generate input actions and output actions by the corresponding alphabets and ends.
\todo{How to say?}
\[
Input(\Sigma,I)=\{\}\cup\{T\}
\]
where we use $T$ to denote the time action.
\[
Output(\Sigma,I)=\{\}
\]

Now we can use Parameterized Mealy Machines to define a new semantics to Reo.
\begin{example}[PMM Semantics of FIFO channel $PM_{FIFO}$]
  The semantics of FIFO channel with source end $A$ and sink end $B$ can be defined as follows
  \begin{itemize}
    \item[-] $S(\Sigma)=\{q_0\}\cup\{q_d|d\in\Sigma\}$
    \item[-] $I=\{A\}$
    \item[-] $O=\{B\}$
    \item[-] $s_0=q_0$
    \item[-] output function
      \begin{displaymath}
        \delta(\Sigma)(s,i)=\left\{
        \begin{array}[h]{ll}
          (B:\bot) & s=q_0\land i=(A:\_,B:\rnoread) \\
          (B:d) & s=q_0\land i=(A:d,B:\rread)\\
          \rblock & s=q_0\land i=(A:\bot,B:\rread) \\
          (B:d) & s=q_d\land i=(A:\_,B:\rread)\\
          \rblock & s=q_d\land i=(A:d,B:\rnoread) \\
          (B:\bot) & s=q_d\land i=(A:\_,B:\rnoread) \\     
        \end{array}
        \right.
      \end{displaymath}
    \item[-] transition function
      \begin{displaymath}
        \lambda(\Sigma)(s,i)=\left\{
        \begin{array}[h]{ll}
          q_d & s=q_0\land i=(A:d,B:\rnoread) \\
          q_d & s=q_{d'}\land i=(A:d,B:\rread) \\
          q_0 & otherwise \\
        \end{array}
        \right.
      \end{displaymath}
  \end{itemize}
\end{example}

\begin{figure}[h]
  \begin{center}
    \input{./images/pmmfifo.tex}
  \end{center}
  \caption{PMM-based Semantics of FIFO, where $\Sigma=\{a,b\}$}
  \label{fig:pmmfifo}
\end{figure}

\begin{definition}[Production of Parameterized Mealy Machines]
  Now we're going to define the production operator \emph{prod} of two parameterized mealy machines as,
  \[
  prod(PM_1,PM_2)=PM_3
  \]
  as follows. Here we assume that $PM_2.O\cap PM_1.I=\varnothing$
  \begin{itemize}
  	\item[-] $\forall\Sigma, PM_3.S(\Sigma)=PM_1.S(\Sigma)\times PM_2.S(\Sigma)$
    \item[-] $PM_3.I=PM_1.I\cup PM_2.I-PM_1.O$
    \item[-] $PM_3.O=PM_1.O\cup PM_2.O-PM_2.I$
    \item[-] $PM_3.s_0=(PM_1.s_0, PM_2.s_0)$
    \item[-] $\forall\Sigma, PM_3.\delta(\Sigma)((s_1,s_2), i)=$
      \begin{displaymath}
        \left\{
        \begin{array}[h]{ll}
          (Out_1 + Out_2)|_{PM_3.O} & \rblock\land Out_2\neq\rblock \\
          \rblock & otherwise \\
        \end{array}
        \right.
      \end{displaymath}
      where we have
      \begin{itemize}
        \item[*] $In_1 = i|_{PM_1.I}$
        \item[*] $Out_1 = PM_1.\delta(\Sigma)(s_1,In_1)$
        \item[*] $In_2 = (Out_1 + i)|_{PM_2.I}$
        \item[*] $Out_2 = PM_2.\delta(\Sigma)(s_2,In_2)$
      \end{itemize}
    \item[-] $\forall\Sigma, PM_3.\lambda(\Sigma)((s_1,s_2),i)=(s_1',s_2')$
      where we have
      \begin{itemize}
        \item[*] $s_1' = PM_1.\lambda(\Sigma)(s_1,In_1)$
        \item[*] $s_2' = PM_2.\lambda(\Sigma)(s_2,In_2)$
      \end{itemize}
  \end{itemize}
\end{definition}

\todo{example of production, maybe fifo+timer}

\section{From Blackbox to Timed Connectors}

\subsection{Observation Table}

\subsection{Closeness}

\subsection{Perfomance Optimization}

\subsection{Counter-Examples}
Generally, equivalence query has been proved impossible in blackbox
models\cite{DBLP:journals/iandc/Angluin87}. However, in this
section, we're showing that in certain circumstances, equivalence query can be implemented with
no approximation.

Equivalence queries are used to search for counter-examples. But what makes counter-examples even
existing? In Reo models, we believe that \emph{FIFO} channels and \emph{Timer} channels are to
blame. Here we present a brief example. To make things eaiser, we have only untimed Reo here.

\begin{figure}[h]
  \begin{center}
    \input{./images/3buf.tex}
  \end{center}
  \caption{A Switching Connector $S$ with Three Buffers}
  \label{fig:buf3}
\end{figure}

A \emph{Switching} connector in \figurename \ref{fig:buf3} has two source-ends $A,B$ and one
sink-end $C$. In a nutshell, datum come from $A$ and be stored temporarily in buffers. These datum
will never flow out until signals come to $B$. With the Mealy-Machine semantics given, the semantics
of \emph{Switching} connectors can be defined as following \figurename \ref{fig:buf3semantics}.

\begin{figure}[h]
  \begin{center}
    \input{./images/3bufsemantics.tex}
  \end{center}
  \caption{\emph{Gate} as Mealy Machine $\mathcal{M}(S)$}
  \label{fig:buf3semantics}
\end{figure}

According to the production of Mealy-Machines, 8 different states should be found in
$\mathcal{M}(S)$. We use $q_{abc}$ to denote them. $q_{001}$ indicates that the last buffer is
filled and others are empty, and $q_{111}$ means that there are no space in any buffer. It's
obvious that some states like $q_{100}$ is unreachable.

We say if two states are \emph{similiar} iff. they have the same output signature.

\begin{theorem}[Bound of Counter-Example]
  \label{the:cebound} Assume that an observation table has already been closed with maximum
  query length \todo{find a better phrase?} $l$. An counter-example of length $l+2$ would be
  found iff. there're possible counter-examples.
\end{theorem}
\begin{IEEEproof}
  Sketch of this proof are shown in several points:
  \begin{enumerate}
    \item Hypothesises are subgraphs of the semantics graph.
    \item Inputs on reverse edges are complementary.
    \item 
  \end{enumerate}
\end{IEEEproof}

\section{Case Studies}
\subsection{Alternator}
\subsection{Timed TODO}

\section{Conclusion and Future Work}



\bibliographystyle{abbrv}
\bibliography{bib}

% FIXME remove this
\listoftodos

\end{document}
